{"mappings":"AAiBA,wBAAgB,MAAM,EAAE,MAAM,QAG7B;AACD,6BAAqB,WAAW,EAAE,MAAM,QAGvC;AACD,6BAAqB,WAAW,EAAE,MAAM,QAGvC;AAED;;;;;;;IAOI;AACJ,qCACE,SAAS,EAAE,MAAM,EACjB,SAAS,CAAC,EAAE,OAAO,EACnB,KAAK,CAAC,EAAE,OAAO,EACf,KAAK,CAAC,EAAE,OAAO,GACd,OAAO,CAAC,GAAG,CAAC,CAcd;AAED,kCAA0B,OAAO,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,OAAO,CAAC,GAAG,EAAE,CAAC,CAIpE;AAED,mCAA2B,OAAO,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC,CAQnE;AAED,8BACE,MAAM,GAAE,MAAY,EACpB,kBAAkB,GAAE,OAAe,GAClC,OAAO,CAAC,GAAG,CAAC,CAEd;AAED,iCAAyB,OAAO,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC,CAOjE;AAED,0BAAkB,IAAI,EAAE,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAE5C;AACD,qCAA6B,OAAO,CAAC,MAAM,CAAC,CAE3C;AAED,gCAAwB,IAAI,EAAE,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAElD;AACD,kCAA0B,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAMtD;AACD,4CAEC;AAED,qCAA6B,OAAO,EAAE,MAAM,GAAG,MAAM,EAAE,MAQtD;AAED,gCAAwB,EAAE,EAAE,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAGhD;AAED,+BACE,OAAO,EAAE,MAAM,EACf,SAAS,EAAE,MAAM,EACjB,OAAO,EAAE,MAAM,GACd,OAAO,CAAC,OAAO,CAAC,CAGlB;;;;;;;;;;;;;;;;;;;;;AASD,wBAoBE","sources":["index.ts"],"sourcesContent":["import { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\r\n\r\nconst ONE_FULL_COIN = 1e8;\r\n\r\nconst URL_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\r\nconst URL_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\r\n\r\nlet username = \"anonymouse\";\r\nlet password = \"anonymous\";\r\nlet url = URL_MAINNET;\r\n\r\nlet rpc = getRPC(username, password, url);\r\n\r\nfunction resetRPC() {\r\n  rpc = getRPC(username, password, url);\r\n  return rpc;\r\n}\r\nfunction setURL(newURL: string) {\r\n  url = newURL;\r\n  resetRPC();\r\n}\r\nfunction setUsername(newUsername: string) {\r\n  username = newUsername;\r\n  resetRPC();\r\n}\r\nfunction setPassword(newPassword: string) {\r\n  password = newPassword;\r\n  resetRPC();\r\n}\r\n\r\n/**\r\n  * \r\n  * @param assetName mandatory\r\n  * @param onlytotal otional, when false result is just a list of addresses with balances -- when true the result is just a single number representing the number of addresses\r\n  * @param count (integer, optional, default=50000, MAX=50000) truncates results to include only the first _count_ assets found\r\n  * @param start (integer, optional, default=0) results skip over the first _start_ assets found (if negative it skips back from the end)\r\n  \r\n  */\r\nfunction getAddressesByAsset(\r\n  assetName: string,\r\n  onlytotal?: boolean,\r\n  count?: boolean,\r\n  start?: boolean\r\n): Promise<any> {\r\n  const _onlytotal = onlytotal === undefined ? false : onlytotal;\r\n  let _count = count === undefined ? 5000 : count;\r\n  let _start = start === undefined ? 0 : start;\r\n  if (_count > 50000) {\r\n    _count = 50000;\r\n  }\r\n\r\n  return rpc(methods.listaddressesbyasset, [\r\n    assetName,\r\n    _onlytotal,\r\n    _count,\r\n    _start,\r\n  ]);\r\n}\r\n\r\nfunction getAddressDeltas(address: string | string[]): Promise<any[]> {\r\n  const addresses = turnIntoStringArray(address);\r\n\r\n  return rpc(methods.getaddressdeltas, [{ addresses: addresses }]);\r\n}\r\n\r\nfunction getAddressMempool(address: string | string[]): Promise<any> {\r\n  const addresses = turnIntoStringArray(address); //Support both string and string array\r\n\r\n  const includeAssets = true;\r\n  return rpc(methods.getaddressmempool, [\r\n    { addresses: addresses },\r\n    includeAssets,\r\n  ]);\r\n}\r\n\r\nfunction getAllAssets(\r\n  prefix: string = \"*\",\r\n  includeAllMetaData: boolean = false\r\n): Promise<any> {\r\n  return rpc(methods.listassets, [prefix, includeAllMetaData]);\r\n}\r\n\r\nfunction getAssetBalance(address: string | string[]): Promise<any> {\r\n  const addresses = turnIntoStringArray;\r\n  const includeAssets = true;\r\n  return rpc(methods.getaddressbalance, [\r\n    { addresses: addresses },\r\n    includeAssets,\r\n  ]);\r\n}\r\n\r\nfunction getAsset(name: string): Promise<any> {\r\n  return rpc(methods.getassetdata, [name]);\r\n}\r\nfunction getBestBlockHash(): Promise<string> {\r\n  return rpc(methods.getbestblockhash, []);\r\n}\r\n\r\nfunction getBlockByHash(hash: string): Promise<any> {\r\n  return rpc(methods.getblock, [hash]);\r\n}\r\nfunction getBlockByHeight(height: number): Promise<any> {\r\n  return rpc(methods.getblockhash, [height]).then((hash) => {\r\n    const verbosity = 3; //include transactions\r\n    const block = rpc(methods.getblock, [hash, verbosity]);\r\n    return block;\r\n  });\r\n}\r\nfunction getMempool() {\r\n  return rpc(methods.getrawmempool, [true]);\r\n}\r\n\r\nfunction getRavencoinBalance(address: string | string[]) {\r\n  const addresses = turnIntoStringArray(address);\r\n  if (!addresses || addresses.length < 1) {\r\n    return {};\r\n  }\r\n  const includeAssets = false;\r\n  const params = [{ addresses: addresses }, includeAssets];\r\n  return rpc(methods.getaddressbalance, params);\r\n}\r\n\r\nfunction getTransaction(id: string): Promise<any> {\r\n  const verbose = true;\r\n  return rpc(methods.getrawtransaction, [id, verbose]);\r\n}\r\n\r\nfunction verifyMessage(\r\n  address: string,\r\n  signature: string,\r\n  message: string\r\n): Promise<boolean> {\r\n  const params = [address, signature, message];\r\n  return rpc(methods.verifymessage, params);\r\n}\r\n\r\nfunction turnIntoStringArray(str: string | string[]): string[] {\r\n  if (typeof str === \"string\") {\r\n    return [str];\r\n  }\r\n  return str;\r\n}\r\n\r\nexport default {\r\n  getAddressesByAsset,\r\n  getAddressDeltas,\r\n  getAddressMempool,\r\n  getAllAssets,\r\n  getAsset,\r\n  getAssetBalance,\r\n  getBestBlockHash,\r\n  getBlockByHash,\r\n  getBlockByHeight,\r\n  getMempool,\r\n  getRavencoinBalance,\r\n  getTransaction,\r\n  setUsername,\r\n  setPassword,\r\n  setURL,\r\n  verifyMessage,\r\n\r\n  URL_MAINNET,\r\n  URL_TESTNET,\r\n};\r\n"],"names":[],"version":3,"file":"types.d.ts.map"}